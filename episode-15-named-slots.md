# Named Slots

### So far, we've been working with components that only required a single, default slot. But, of course in real life, you'll encounter situations where you need to insert content in multiple areas. In these cases, we can used named slots.

Here's the full transcript for Episode 15 "Named Slots" from the "Learn Vue 3: Step by Step" series on Laracasts:

Now, so far we've only needed to create components that accepted a single default slot. But of course, in real life, for more practical applications, what you'll find is some of your components require multiple slots. So let me show you how to do that in this episode. Maybe each of these sections you see here should be their own little panels or cards. So let's do that now. To assignment list, we'll say, how about a background color of like gray 700, maybe a little padding, a border, maybe a border color that's slightly lighter than the background color, and then maybe make it rounded. Let's see how that looks.
[color, and then maybe make it rounded. Let's see how that looks. Yeah, and that'll do the trick. So we have these little cards here. But now, as you can imagine, you'll probably want to reuse these cards. So let's see. Right now, what you would have to do, let's wrap this within a div. Like so. And yeah, maybe down here, we will want another card. So what you'll do is you'll return to someplace where you already used it.
And yeah, maybe down here, we will want another card. So what you'll do is you'll return to someplace where you already used it. And you'll see, okay, it looks like we have these styles, and it looks like there's a heading two that is bold with margin. And yeah, you'll just, you'll paste it on here. Heading two, font bold, hello world. And yeah, this will do the trick. So if I come back and give it a refresh, so yeah, it works, but it's not ideal. And of course, as the application grows, there becomes greater opportunity for these things to become out of sync.
And of course, as the application grows, there becomes greater opportunity for these things to become out of sync. So we should fix that. Now notice, this is right up against the edge. Real quick, let's set a class of grid, mostly so I can add some gap all around the children like that. Okay, so let's do this. Let's create a new component. We'll call it panel or card, whatever you want. And this will be responsible for our card styling and any behavior we apply to it.
We'll call it panel or card, whatever you want. And this will be responsible for our card styling and any behavior we apply to it. So let's come back. I will snatch all of that and move it over. Now for the heading here, we could either use slots or props, and which one you choose just sort of depends on how flexible it needs to be. Let's start with a prop. So maybe we have a prop called heading, all right? Props will accept a heading, that's a string. So we can use the mustache syntax here, or don't forget, you could also use V text.
Props will accept a heading, that's a string. So we can use the mustache syntax here, or don't forget, you could also use V text. Same thing. Cool. So now let's use it. As always, we import it. And we register it as a component, and then we use it. Panel, heading is hello world. Okay, so if we come back and give it a refresh, we get the same thing. Perfect.
Okay, so if we come back and give it a refresh, we get the same thing. Perfect. But yeah, what will end up happening is this will be fine for a while, but then you'll need to create a panel where the heading has some kind of icon. Maybe there's some SVG or a small tag that you want to be included there, but you're not sure how to do it because you're just passing this in as a string. So you can make these a little more flexible by switching over to slots like this. If we know it's always going to be an H2, we could then say, well, here is a slots. And now within this H2, you can put whatever you want, and it'll be slotted in there. Okay.
And now within this H2, you can put whatever you want, and it'll be slotted in there. Okay. So now we do this. Hello again. Switch back, refresh, and it works. And yet again, if I need to nest some SVG there, it's going to work. I'm not limited to just a string prop. Cool. But next, of course, maybe we want a body section to go below it. So now we're in a situation where we need more than just a default slot.
But next, of course, maybe we want a body section to go below it. So now we're in a situation where we need more than just a default slot. We also want something down here, but now we need a way to distinguish between these two. Which one is the default slots? And we solve this by applying a name. Why don't we say this is our default slots, and this one has a name of heading. So this is heading, this is effectively default. Same thing. Okay.
Same thing. Okay. Cool. So now when we switch back, I can say, okay, this is my default content. And if we come back, that will be inserted there. But actually as it turns out, there's a long form way that we can do this. We can add a template tag here. I'll paste that in. And then we can use this V slot directive. And we'll need to give it the name of the slots.
And then we can use this V slot directive. And we'll need to give it the name of the slots. It's default. So this should do the exact same thing. And it does. It's sort of the long form way of declaring your default slots. Now I show you this because if we also want a heading slot, we're going to use the exact same approach. The slot for the heading. And again, notice this is coming from this.
The slot for the heading. And again, notice this is coming from this. So if I change this to title, then I would come back here and I would say V slot title. Okay. So now if I come back and refresh, we're up and running here. Okay. So granted, it's a little more verbose, I get it, but it's also a little more flexible. So you just have to decide which one is appropriate. And don't forget because your default slots is assumed, you can remove this and that would still do the exact same thing.
And don't forget because your default slots is assumed, you can remove this and that would still do the exact same thing. Okay. But now, yeah, what about situations? Let's do this. Let's create another panel and we'll say this top one only has some text, but this second one also has a heading. Let's see how it deals with that. Okay. It seems like it's fine, but one little issue is if we go up here, you'll see that it's
Okay. It seems like it's fine, but one little issue is if we go up here, you'll see that it's still rendering the H2 tag. It's just an empty tag. We don't want that. So let's see what we can do here. It sounds like we want to say, well, look, only render this H2 if we have a heading slot that is being passed in. So I can do that by saying V if, and all of your slots are going to be stored within this view property called $slots.
So I can do that by saying V if, and all of your slots are going to be stored within this view property called $slots. So if we have something for heading, and again, that just means if you provided V slot heading anywhere for the component, then and only then should we render an H2. Okay. So we think that should solve the problem. If we take a look, this one doesn't have a heading, so we don't render an H2. This one does, so we do render an H2. And yeah, you can imagine we could do the exact same thing for maybe a footer. This could be your slot for the footer, but we only want to render that if you provided
And yeah, you can imagine we could do the exact same thing for maybe a footer. This could be your slot for the footer, but we only want to render that if you provided something for the footer. So this is a way that we can create more configurable and flexible components. Let's see what that looks like. If we come back, I will make another component here that has a heading, a default slot, and then maybe also a footer. Click here to learn more, you know, something like that. All right, come back, refresh, and now we have three different ways to display these cards.
All right, come back, refresh, and now we have three different ways to display these cards. And granted, I don't have any styling for the footer. What could we do there? Maybe if nothing else, like a border on the top, and maybe a little margin, a little padding, and let's set the border color to gray 600. Yeah, just something to make it look a little more pretty. Okay, I'll paste that in. And there we go. And actually, maybe we should also make the text smaller in the footer.
And there we go. And actually, maybe we should also make the text smaller in the footer. Yeah. And then finally, maybe a little margin bottom on H2, but only if a heading was provided, just to push it down. And there we go. Three different ways to present our card. But we could even take it further. Maybe we also want to support themes. And we'll say we have a light theme and a dark theme.
Maybe we also want to support themes. And we'll say we have a light theme and a dark theme. So I could say theme is a string and the default is dark. So what we'll do is read this theme property to determine which classes should be applied. Let's do this. We'll say this is what we started with. But then we'll say, well, look, if the theme is dark, then what CSS classes should be applied? Well, maybe the background color. And then what else? The border gray, maybe that's it.
And then what else? The border gray, maybe that's it. Those are the dark theme styles. But if the theme is light, then maybe we'll say, well, in that case, use a background color of white, and then maybe a border that is gray 300. Okay. Let's give that one a shot now. So we'll do yet another panel down here. But this time, the panel has a light theme. Come back, refresh, and ooh, that's not working.
But this time, the panel has a light theme. Come back, refresh, and ooh, that's not working. Okay. So let's use feedbind and give it a run. So we load this in the browser, and there we go. You know what? It looks like we need to force black text. So we'll say text black if the theme is light, and text white if the theme is dark. And there we go. So yeah, the entire point is to demonstrate that if you take a little bit of time, you
And there we go. So yeah, the entire point is to demonstrate that if you take a little bit of time, you can slowly build up a set of flexible and configurable components that you can use anywhere in the application. So now the only remaining step is to use this for our assignments. So we'll go into assignment list. Once again, import our panel, register it as a component, and then use it like that. That will self-close automatically. And then I can get rid of some of these classes because the component is now responsible for that.
And then I can get rid of some of these classes because the component is now responsible for that. But a quick little tip, any attributes you pass to a component will automatically be added to the root element of the component. So this allows you to merge in classes from the outside. Or for example, maybe, excuse me, for example, maybe you want to give this particular component or panel an ID. Well, it's not like I have to declare an ID prop on panel. No, these are regular attributes, and they will be sent through to the top level element of your component.
No, these are regular attributes, and they will be sent through to the top level element of your component. So if I come back and give this a refresh, this should have an ID of my panel, and it does. And you can see that width of 60 was merged in with the default classes. So that's a really important technique to be aware of. Switch back, remove the ID, and yeah, we're up and running. So now if we do decide that we need some kind of a footer, then just like before, I could say template vslot footer, and then we'll say my footer goes here, and this should now display between or at the bottom of every assignment list, and it does.
say template vslot footer, and then we'll say my footer goes here, and this should now display between or at the bottom of every assignment list, and it does. Okay, so finally, I will leave you with a quick little tip. So just like we have shorthand for declaring event listeners or attribute binding, the same is true for vslot, and that is through the use of the pound sign. So vslot footer or pound footer, exact same thing, as you can see here. And yeah, I will almost always take this approach in my own projects. Okay, you're doing great. Let's move on to the next episode.

You can also view the transcript in segments on Laracasts here: 0:00-7:00

If you want me to extract or explain any part of this episode, just ask!


## Translation

Aqui está a transcrição completa do Episódio 15 "Slots Nomeados" da série "Learn Vue 3: Step by Step" no Laracasts:

Até agora, só precisávamos criar componentes que aceitassem um único slot padrão. Mas claro, na vida real, em aplicações mais práticas, você vai perceber que alguns dos seus componentes vão exigir múltiplos slots. Então deixa eu te mostrar como fazer isso neste episódio. Talvez cada uma dessas seções que você vê aqui deva ser seu próprio pequeno painel ou cartão. Vamos fazer isso agora. Para a lista de tarefas, vamos dizer… que tal um fundo cinza 700, talvez um pouco de padding, uma borda, talvez uma cor de borda um pouco mais clara que a cor de fundo, e então talvez deixá-lo com cantos arredondados. Vamos ver como fica.

Sim, isso deve funcionar. Agora temos esses pequenos cartões aqui. Mas, como você pode imaginar, provavelmente vai querer reutilizar esses cartões. Então vamos ver. Agora, o que você teria que fazer é embrulhar isso em uma div. Assim. E sim, talvez aqui embaixo a gente queira outro cartão. O que você faz então é voltar para algum lugar onde já o usou.

E verá, ok, parece que temos esses estilos, parece que há um título H2 em negrito com margem. E sim, você vai simplesmente colar isso aqui. Título H2, fonte negrito, "Hello World". E sim, isso deve funcionar. Se eu voltar e recarregar, funciona, mas não é o ideal. E claro, à medida que a aplicação cresce, aumentam as chances dessas coisas ficarem fora de sincronia.

Então devemos corrigir isso. Repare que está colado na borda. Rapidinho, vamos definir uma classe grid, principalmente para adicionar um espaçamento (gap) entre os filhos. Pronto, vamos fazer o seguinte. Vamos criar um novo componente. Vamos chamá-lo de Panel ou Card, como preferir. E ele será responsável pela estilização e qualquer comportamento desses cartões.

Vamos voltar e pegar todo aquele código e mover para lá. Agora, para o título, podemos usar slots ou props, e qual você escolhe depende de quão flexível ele precisa ser. Vamos começar com uma prop. Talvez uma prop chamada heading, tudo bem? Props aceitarão heading como uma string. Podemos usar a sintaxe de mustache aqui, ou não se esqueça, também dá pra usar v-text.

Mesma coisa. Legal. Agora vamos usá-lo. Como sempre, importamos, registramos como componente e então usamos. Panel, heading="Hello World". Beleza, se eu voltar e recarregar, temos a mesma coisa. Perfeito.

Mas, o que acaba acontecendo é que isso funciona por um tempo, mas depois você vai querer criar um painel onde o título tenha algum ícone. Talvez um SVG ou uma tag pequena que você quer incluir, mas não sabe como fazer porque está apenas passando uma string. Então você pode tornar isso um pouco mais flexível mudando para slots, assim: se sabemos que será sempre um H2, podemos dizer: aqui vai o slot. E agora, dentro desse H2, você pode colocar o que quiser, e será inserido ali.

Agora fazemos assim: "Hello again". Voltamos, recarregamos, e funciona. E mais uma vez, se eu quiser aninhar um SVG ali, funciona. Não estou limitado a apenas uma prop string. Legal. Mas agora, claro, talvez a gente queira uma seção de corpo logo abaixo. Então estamos numa situação onde precisamos de mais do que apenas um slot padrão.

Queremos algo aqui embaixo também, mas precisamos distinguir entre esses dois. Qual é o slot padrão? E resolvemos isso aplicando um nome. Vamos dizer que este é o nosso slot padrão, e este aqui recebe o nome heading. Então este é heading, aquele é default. Mesma coisa. Beleza.

Agora, ao voltarmos, posso dizer: "este é o meu conteúdo padrão". E se voltarmos, será inserido ali. Mas, na verdade, há uma forma mais longa de fazer isso. Podemos adicionar uma tag <template> aqui. Vou colar. E aí usamos a diretiva v-slot, e precisamos passar o nome do slot.

No caso, default. Isso deve fazer exatamente a mesma coisa. E faz. É a forma longa de declarar seu slot padrão. Estou te mostrando isso porque, se quisermos também um slot heading, vamos usar exatamente o mesmo formato. Slot para o heading. E de novo, veja que isso vem daqui.

Se eu mudar de heading para title, volto aqui e digo v-slot:title. Beleza. Se eu recarregar, está funcionando. Ok. É um pouco mais verboso, eu sei, mas também é mais flexível. Você só precisa decidir qual abordagem usar. E não se esqueça: como o slot padrão é assumido, você pode remover isso e ainda vai funcionar exatamente da mesma forma.

Mas agora, e se tivermos situações como… vamos criar outro painel e vamos dizer que este de cima só tem algum texto, mas o segundo também tem um título. Vamos ver como isso se comporta. Parece que está tudo bem, mas um pequeno problema é que, se subirmos aqui, verá que ele ainda está renderizando a tag H2. Só que está vazia. Não queremos isso. Então o que podemos fazer?

Queremos dizer: olha, só renderize esse H2 se tivermos um slot heading sendo passado. Podemos fazer isso com v-if. Todos os seus slots ficam armazenados na propriedade $slots do componente. Então se tivermos algo para heading, e de novo, isso significa que você forneceu v-slot:heading em algum lugar para esse componente, então e só então deve-se renderizar o H2.

Acreditamos que isso resolve o problema. Se olharmos, esse aqui não tem heading, então não renderiza um H2. Este tem, então renderiza. E sim, dá pra imaginar que podemos fazer exatamente a mesma coisa para um rodapé. Pode ser um slot footer, mas só queremos renderizá-lo se você tiver fornecido algo para ele. Essa é uma forma de criar componentes mais configuráveis e flexíveis. Vamos ver como fica.

Se voltarmos, vou criar outro componente aqui com heading, slot padrão e talvez um footer. "Clique aqui para saber mais", algo assim. Beleza, voltamos, recarregamos e agora temos três formas diferentes de exibir esses cartões.

Claro, ainda não temos nenhuma estilização para o footer. O que podemos fazer ali? Talvez, no mínimo, uma borda no topo, um pouco de margem, padding, e definir a cor da borda como cinza 600. Só para deixá-lo mais bonito. Ok, vou colar isso. E pronto. E talvez devêssemos também diminuir o tamanho do texto do rodapé.

Sim. E, por fim, talvez uma margem inferior no H2, mas só se um título foi fornecido, só pra empurrar ele um pouco pra baixo. Pronto. Três maneiras diferentes de apresentar nosso cartão. Mas podemos ir além. Talvez também queiramos suportar temas. Podemos dizer que temos um tema claro e um escuro.

Então posso dizer que theme é uma string, com valor padrão dark. O que faremos é ler essa prop theme para determinar quais classes devem ser aplicadas. Vamos fazer assim. Dizemos que isso é o que começamos. Mas então dizemos: se o tema é dark, quais classes CSS devem ser aplicadas? Talvez cor de fundo, borda cinza, talvez só isso.

Esses são os estilos do tema escuro. Mas se o tema for light, então talvez digamos: neste caso, use cor de fundo branca, e borda cinza 300. Beleza. Vamos testar agora. Fazemos mais um painel aqui embaixo. Mas dessa vez, com o tema light. Voltamos, recarregamos e… ops, não funcionou.

Ok, vamos usar v-bind e testar. Abrimos no navegador, e aí está. Só que parece que precisamos forçar texto preto. Então diremos: text-black se o tema for claro, e text-white se for escuro. Pronto. __O objetivo é mostrar que, se você dedicar um pouco de tempo, pode ir construindo lentamente um conjunto de componentes flexíveis e configuráveis para usar em qualquer parte da aplicação__.

Agora, o único passo restante é usar isso para nossas tarefas. Então vamos em assignmentList, mais uma vez, importamos o Panel, registramos como componente, e então usamos assim. Ele se autocompleta. Aí posso remover algumas dessas classes porque agora o componente é responsável por isso.

Mas uma dica rápida: quaisquer atributos que você passar para um componente serão automaticamente adicionados ao elemento raiz do componente. Isso permite mesclar classes externas. Ou, por exemplo, talvez você queira dar um id a esse componente ou painel. Não é necessário declarar uma prop id no Panel. Esses são atributos normais e serão repassados para o elemento de nível superior do componente.

Então, se eu recarregar, esse painel deve ter um ID my-panel, e tem. E você pode ver que a largura 60 foi mesclada com as classes padrão. Essa é uma técnica bem importante. Voltamos, removemos o ID, e estamos funcionando. Agora, se decidirmos que precisamos de um rodapé, assim como antes, podemos dizer template v-slot:footer, e depois "meu rodapé vai aqui", e isso será exibido na parte inferior da lista de tarefas, e funciona.

Beleza, então, finalmente, deixo aqui uma última dica. Assim como temos atalhos para declarar ouvintes de eventos ou vinculação de atributos, o mesmo vale para v-slot, que pode ser usado com o símbolo de cerquilha (#). Então v-slot:footer ou #footer, mesma coisa, como você pode ver aqui. E sim, eu quase sempre uso esse formato nos meus próprios projetos. Beleza, você está indo muito bem. Vamos para o próximo episódio.