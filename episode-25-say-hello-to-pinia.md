# Say Hello to Pinia

###

Here is the full transcript for Episode 25 "Say Hello to Pinia" from the "Learn Vue 3: Step by Step" series on Laracasts:

Okay, I think we're now ready to move on and finally review some dedicated tooling for dealing with global state management. And the tool I'm going to show you is sort of the de facto tool. It's one called Pinia. But real quick, before we get started, if you're researching this on your own, you also might come across a tool called Vuex, however you want to pronounce it. You can safely ignore that. Pinia is the official replacement for Vuex. So you know what, you don't even need to consider it. Just move on straight to Pinia.
0:00-0:59

So you know what, you don't even need to consider it. Just move on straight to Pinia. All right, let's get going. All right, so here's what I'd like to do. In the next chapter, we're going to put all these pieces together and whip up a small little example project. But for now, just to demonstrate the basic workflow, I want to take the makeshift counter store that we created in the last couple episodes and convert this to Pinia. All right, let's get going. npm install pinia.
0:31-0:87

All right, next I'm going to go into my entry point, which is main.js. All right, and let's import it, createPinia from pinia. And then we're going to register it as a plugin. So we can do it by saying app.use(createPinia()) and that's it. We're ready to go. So now if we go to counter store, in terms of file naming conventions, again, you can do whatever you want. Whatever your company is already doing is what you should do. But you also might see people use capital letters. And that's what I generally do. So again, whatever you want. But this is generally what I prefer.
0:55-1:07

OK, next I'm going to delete all of this and rebuild it from scratch. To begin, we want to define a new store. So I can import defineStore from pinia. All right, let's call that now. Now the first argument is going to be a name. It can be anything you want. In our case, counter would be perfectly fine. And mostly this is used when wiring up to DevTools. And I'll show you that in a minute. Next we're going to have an object where we can declare the state, any actions we might have, any getters or computed properties. All of that will go here. So in our case, rather than doing it at the top level, like we did in the last episode, I'm instead going to define a function called state, and that can return an object. So very similar to your standard Vue components.
1:39-2:10

OK, so now let's assign this to a variable. So I could do something like this. But again, following typical conventions, this is very similar to composables, we might begin it with use. So useCounterStore. But again, whatever you want to call it works for me. All right, the only remaining step, of course, is to export this. And we're ready to go. So now if I come back to counter view, let's do this. We're going to import useCounterStore from our new store. And the only difference here is I need to call this function.
2:32-3:32

OK, let's do it like this. Let counter = useCounterStore(). OK, so now this should mostly reproduce what we had in the previous episode. The only difference is this section right here, where we call an increment function or a function. For now, just to show you that you can, let's mutate it directly. So I can say counter.count++. And this is important. Notice that I'm able to access count directly off of our store here, even though it's within a state function that returns an object, I can still access it as if it was declared on the top level. OK, so now if I come back to Chrome and give it a refresh, this should do exactly what it did in the last episode, and it does. But now we have some cool wins that come from this. For example, if I go to the Vue tab, well, a couple of things. Notice we had this new Pinia tab.
3:27-5:13

And at this point, notice we only have the one store, counter. So notice that is the same name as what we have here. If I changed it to myCounter and come back, let's give it a little refresh. Sure enough, that name gets updated. So it's like an identifier. OK, let's bring it back to counter. So anyways, one more refresh, and I can see the initial count is zero. I can increment it. It stays in sync. And of course, I can tweak this on my own. And when we do, that will, of course, be reflected on the page. Cool. Next, we have general time travel functionality. So notice if I switch over here to the timeline, I have this new Pinia section. And we can see if I increment this, we get a new one. If I hover over it, what do we have? We have a mutation on the counter store. The old value is 9, and the new value was 10. So this is incredibly useful for debugging. And if I keep doing this, notice that I have time travel support. So I'm sorry, this is a little hard to see. But notice if I hover over these, I can time travel back to the previous values. Or I can advance the timeline back to what we currently have. Pretty cool.
5:13-5:53

OK, but anyways, what else? Let's go back to our counter view. So yes, we can mutate our state directly. But again, if you'd rather reach for dedicated actions, we should return that counter.increment function that we had in the last episode. All right, let's switch back to counter store. And again, the only difference is rather than defining it here, I'm going to nest it within an actions object. So we will increment this. And notice I can interact again. I can interact with the state as if it's a top-level property on the object. So very similar to how you'd work with the options API. So we switch back, and now that's working as well. Pretty cool. But now, what about that silly guard logic we had before, where you can't increment past 10?
5:49-6:27

But now, what about that silly guard logic we had before, where you can't increment past 10? OK, let's do this. Why don't we say, well, if the current count is less than 10, only on that condition will we increment it. And that'll do it. So if we give it a shot, I can go up to 10, but I can't go beyond that. But what if we also want to extend this? Maybe the button will tell you how many more times you can click it. So in this case, it would say increment 5, increment 4, 3, 2. How would we do that? Well, of course, we would reach for a traditional computed property. Or within the context of a store, we could call that a getter. Same thing. Create a getters object, and this is effectively your computed properties. So we might have one called remaining, where, hmm, how do we want to do this? Well, we might want to extract the maximum count, but for now, I'll just do a little duplication and say return 10 minus the current count. And now we have our getter.
6:18-7:22

All right, let's use it. Switch back, and maybe we'll do it right within here. In parentheses, we'll say counter.remaining. We access it just like any other state or any other computed property. And then I can say remaining. Okay, so let's give that a refresh. And sure enough, 5 remaining, 4, 3, 2. It's all so easy. And we could even disable this button. Here, let's clean this up just a little bit. We could disable the button if there are no remaining clicks. Disabled equals not counter.remaining. Okay, switch back. We have hot reloading here. And sure enough, that button is deactivated. But if we refresh, it's active, active, active, active, inactive. Or disabled.
7:12-7:58

Okay, so now, hopefully, this is all starting to make good sense. If I switch back to my counter store, we can see that a typical Pinia store is split up into three components, so to speak. You have your state, your actions, and your getters. And again, if that's confusing, in your head, just map it. State is your data. It's just your data that you're keeping track of. Your actions are functions. They're just your methods. And then your getters are your computed properties. They're effectively the same thing. They just have different names. But in your head, do this mapping, and then you'll completely understand it. Okay, so I think we've reviewed the absolute basics. And I don't do that to be condescending. When I'm learning something new, I do sort of want to be treated like a three-year-old. Just give me the basic, the most basic possible example so that I can understand this. But now I think you're ready. In the next chapter, why don't we build something with a little more substance? Something that we can still build in 20 or 30 minutes. But nonetheless, something that will demonstrate all of these components and techniques. I'll see you then.
7:48-8:55

If you want to see any specific part or example from the episode, just ask!

## Translation

Aqui está a tradução completa do texto solicitado do Episódio 25 “Say Hello to Pinia” da série "Learn Vue 3: Step by Step" do Laracasts:

Tudo bem, acho que agora estamos prontos para seguir em frente e finalmente revisar algumas ferramentas dedicadas ao gerenciamento de estado global. E a ferramenta que vou te mostrar é meio que a ferramenta padrão. Ela se chama Pinia. Mas bem rápido, antes de começarmos, se você estiver pesquisando isso por conta própria, talvez também se depare com uma ferramenta chamada Vuex (pronuncie como quiser). Você pode ignorar isso tranquilamente. Pinia é o substituto oficial do Vuex. Então, sabe de uma coisa? Você nem precisa considerar o Vuex. Vá direto para o Pinia.

Então, como eu disse, nem precisa considerar o Vuex. Vá direto para o Pinia. Tudo certo, vamos começar. Aqui está o que eu quero fazer. No próximo capítulo, vamos juntar todas as peças e montar um pequeno projeto de exemplo. Mas, por agora, só para demonstrar o fluxo básico, quero pegar a store improvisada de contador que criamos nos últimos episódios e convertê-la para o Pinia. Beleza, vamos nessa. npm install pinia.

Certo, agora vou até meu ponto de entrada, o main.js. E vamos importá-lo: createPinia do pinia. Depois, vamos registrá-lo como um plugin. Podemos fazer isso com: app.use(createPinia()). E pronto, estamos prontos para começar. Agora, se formos para a store do contador, em relação à convenção de nomes dos arquivos, novamente, você pode fazer como quiser. O que sua empresa já estiver fazendo, siga isso. Mas você também pode ver pessoas usando letras maiúsculas — é o que geralmente faço. Enfim, como preferir. Mas geralmente prefiro assim.

Certo, agora vou deletar tudo isso e reconstruir do zero. Para começar, queremos definir uma nova store. Então importamos defineStore do pinia. Beleza, vamos chamar isso agora. O primeiro argumento será um nome — pode ser qualquer coisa. No nosso caso, counter está ótimo. Esse nome é usado principalmente para integração com o DevTools. Vou te mostrar isso em um minuto. Depois, temos um objeto onde podemos declarar o state, quaisquer actions que tivermos, getters ou propriedades computadas. Tudo isso vai aqui. No nosso caso, em vez de fazer isso no nível superior como fizemos no último episódio, vou definir uma função chamada state, que retorna um objeto — bem parecido com componentes Vue padrão.

Agora vamos atribuir isso a uma variável. Poderíamos fazer algo assim. Mas, seguindo convenções típicas (parecido com composables), podemos começar com use. Então: useCounterStore. Mas, de novo, chame como quiser. Agora, o único passo restante é exportar isso. E pronto. Agora, se eu voltar para a CounterView, vamos fazer o seguinte. Vamos importar useCounterStore da nossa nova store. E a única diferença aqui é que precisamos chamar essa função.

Vamos fazer assim: let counter = useCounterStore(). Agora isso deve basicamente reproduzir o que tínhamos no episódio anterior. A única diferença está nesta parte aqui, onde chamamos a função increment. Por ora, só para mostrar que podemos, vamos fazer a mutação diretamente. Então: counter.count++. E isso é importante. Veja que consigo acessar count diretamente da nossa store aqui, mesmo estando dentro de uma função state que retorna um objeto — ainda consigo acessá-la como se estivesse no nível superior. Agora, se eu voltar ao Chrome e der um refresh, isso deve fazer exatamente o que fazia antes — e faz. Mas agora temos algumas vantagens legais com isso. Por exemplo, se eu for para a aba Vue, olha só — temos uma nova aba chamada Pinia.

Nesse ponto, temos apenas uma store: counter. Veja que é o mesmo nome que usamos aqui. Se eu mudá-lo para myCounter e voltar, depois de um refresh, esse nome é atualizado. É como um identificador. Vamos voltar para counter. Outro refresh, vejo que o count inicial é zero. Posso incrementá-lo, ele permanece em sincronia. Posso modificar isso manualmente também, e será refletido na página. Legal. Temos também funcionalidade de viagem no tempo. Se eu mudar para a aba de timeline, aparece uma seção do Pinia. E se eu incrementar, aparece uma nova entrada. Ao passar o mouse, vemos uma mutação na store counter. Valor antigo era 9, e o novo é 10. Isso é extremamente útil para depuração. E se eu continuar, temos suporte à viagem no tempo. É meio difícil de ver aqui, mas ao passar o mouse, posso voltar para valores anteriores — ou avançar para o valor atual. Bem legal.

Voltando à CounterView. Sim, podemos mutar o estado diretamente. Mas se você preferir usar ações dedicadas, devemos retornar aquela função counter.increment que tínhamos antes. Vamos voltar à counterStore. A única diferença é que, em vez de defini-la no topo, vou colocá-la dentro de um objeto actions. E veja que consigo interagir com o state como se fosse uma propriedade de nível superior no objeto — bem parecido com a Options API. Voltando, e agora isso também está funcionando. Legal. Mas e aquela lógica de guarda que tínhamos, onde você não podia incrementar acima de 10?

Vamos fazer isso: se o count atual for menor que 10, só nesse caso incrementamos. E pronto. Vamos testar: posso ir até 10, mas não além disso. Mas e se quisermos estender isso? Talvez o botão mostre quantas vezes ainda pode ser clicado. Tipo: "Incrementar (5)", "Incrementar (4)", etc. Como faríamos isso? Claro, usaríamos uma propriedade computada tradicional. Ou, dentro de uma store, chamamos isso de getter. Mesma coisa. Criamos um objeto getters, que é onde vão suas propriedades computadas. Podemos criar um chamado remaining, onde — como fazemos isso? Talvez extraindo o valor máximo, mas por agora, só vou duplicar e dizer: return 10 - count. Pronto, temos nosso getter.

Vamos usá-lo. Voltando, podemos colocá-lo aqui mesmo: entre parênteses, counter.remaining. Acessamos como qualquer outro state ou propriedade computada. Vamos testar: 5 restantes, 4, 3, 2... Muito fácil. Podemos até desabilitar o botão. Vamos limpar um pouco. Podemos dizer: disabled = !counter.remaining. Voltando. O hot reload está ativo. E de fato: botão desativado. Se atualizarmos: ativo, ativo, ativo... desativado.

Agora, espero que tudo isso esteja começando a fazer sentido. Se eu voltar para a store do contador, vemos que uma store típica do Pinia é dividida em três partes, por assim dizer: você tem state, actions e getters. E se isso for confuso, pense assim: state são seus dados — os dados que você está rastreando. Actions são funções — seus métodos. E getters são suas propriedades computadas. São efetivamente a mesma coisa. Só têm nomes diferentes. Mas, mentalmente, faça esse mapeamento, e você vai entender tudo. Beleza, acho que cobrimos o básico. E não faço isso de forma condescendente. Quando estou aprendendo algo novo, gosto que me tratem como uma criança de 3 anos. Só me dê o exemplo mais básico possível para eu entender. Mas agora acho que você está pronto. No próximo capítulo, por que não construímos algo com um pouco mais de substância? Algo que ainda possamos fazer em 20 ou 30 minutos, mas que demonstre todos esses componentes e técnicas. Te vejo lá.

## Summary

In Episode 25, Jeffrey introduces Pinia as the modern, official state management tool for Vue 3, replacing Vuex entirely. He walks through setting up Pinia by installing it via npm, registering it as a plugin in your main.js, and then creating a store using defineStore. The store is structured into three main parts: state (your reactive data), actions (methods to mutate state), and getters (computed properties derived from state).

Jeffrey demonstrates converting a simple counter store to Pinia, showing how state can be accessed and mutated directly, or via actions for better encapsulation. He also highlights Pinia's integration with Vue DevTools, which provides time-travel debugging and mutation tracking, making state changes easy to follow and debug.

Finally, he adds guard logic inside an action to prevent incrementing beyond a limit and uses a getter to compute how many increments remain, showing how to bind this reactive data to the UI, including disabling a button when no increments remain.

This episode lays out the fundamental workflow and structure of Pinia stores, making global state management in Vue 3 straightforward and powerful.