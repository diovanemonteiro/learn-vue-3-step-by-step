# Lifecycle Hooks, Fake APIs, and AJAX

### So far, we've been hard-coding the list of assignments directly within our Vue component. But of course, that's not overly realistic. Let's switch over to using the `fetch()`  JavaScript API to request data from a fake API.

Here is the full transcript for Episode 13 "Lifecycle Hooks, Fake APIs, and AJAX" from the "Learn Vue 3: Step by Step" series on Laracasts:

All right, welcome back. Let's move on to something else. So far, we've been hard-coding the assignments directly within our component. But of course, that's not overly realistic. In real life, it's coming from a database or an API of some sort. So why don't we try to test that out using a fake API? I'll show you how. I will open my editor. And yeah, of course, right now, we don't have a backend. We just have a bunch of JavaScript files.

And yeah, of course, right now, we don't have a backend. We just have a bunch of JavaScript files. So of course, I could pull in Laravel to provide our API. But I'm also right now sensitive to the fact that many people watching this possibly don't use PHP or Laravel. So even though we might reach for it in the future, right now in the series, I want these examples to be as broadly accessible as possible. So with that in mind, I'm going to set up a fake API, and I'll show you a cool way to do that. So I'm going to use NPM to install a tool called JSON Server, and I'll save that to my dev dependencies list. Now if you run NPM and it doesn't work, visit nodejs.org and install it, and then try to run this again. Okay, so now if I try to run this, and I can do that by saying npx json server, it brings up the help, but also we see a little note here. Hey, we're missing the source argument. So we need to create a database that it can work off of. Okay, let's do that now.

So we need to create a database that it can work off of. Okay, let's do that now. So remember, we're not creating a real database. This is just a fake API for testing, and it's perfect for examples. I will call it db.json. And yeah, check out how cool this is. If I want an endpoint to fetch assignments, let's call it assignments, and that should return an array of assignments. So if we switch over, here's what we had before. Why don't we copy one of those, switch over to our database, and then paste it in.

So if we switch over, here's what we had before. Why don't we copy one of those, switch over to our database, and then paste it in. But of course, right now it's going to fail because it's not formatted properly. So let's make sure we wrap everything with double quotes, like this. And then I will reformat. All right, and that's the basic shape. If I want to add more, I can duplicate this as many times as I need to. Now when I make a request to the assignment's endpoint, it will return to me all of these objects. Okay, cool.

So to save time, I'm not going to make you watch all of this. Let me paste in one that I wrote earlier. And notice the names here perfectly correspond to the ones that we hardcoded within assignments.js. So ideally, I should be able to remove all of these, and instead fetch them from our new fake API. Okay, let's run it again. npx json-server, and then the filename is db.json. Very cool.

npx json-server, and then the filename is db.json. Very cool. I have an assignments resource ready to go. But there is one little issue. Notice it's trying to run on port 3,000, but our main server is also running on port 3,000. Why don't we exit out, do it one more time, and I will set the port to 3,001. Okay, that way they won't interfere. So check this out. If I open this in the browser, our server is up and running, and here's our assignments endpoint that will return this data.

If I open this in the browser, our server is up and running, and here's our assignments endpoint that will return this data. Yeah, how cool is that? It's perfect. Exactly what we need for testing purposes. Okay, now let's make a request to this endpoint. And I'll show you how to do that. If we visit assignments.js, where would be a good place to make an AJAX request? Okay, well this is where lifecycle hooks come into play. So why don't we take a look at this diagram that Vue.js provides.

Okay, well this is where lifecycle hooks come into play. So why don't we take a look at this diagram that Vue.js provides. Yeah, here we go. So this is the lifecycle for a component. And granted, it looks a little confusing. Nobody expects you to memorize every piece of this flow. Just understand the basic idea. As a component is rendered, mounted, and then unmounted, it will work its way through a series of lifecycle hooks. And here's some common ones.

a series of lifecycle hooks. And here's some common ones. Before create, create, mounted, unmounted. So for example, if we want to execute a bit of code right when the component has been created but it hasn't yet been compiled, then the created hook is what we want. And as it turns out, the names of these hooks are also the method names we use. So for example, created, alert, created, and let's give it a shot. Refresh, and it works. Okay, so the most common ones you'll use are created, mounted, and this means the component has been created, compiled, and rendered to the DOM.

Okay, so the most common ones you'll use are created, mounted, and this means the component has been created, compiled, and rendered to the DOM. So that's a very common one. And then another common one is after the component has been unmounted from the page. And you'll often reach for unmounted when building single page applications, where maybe you need to remove event listeners so that you can free up memory. Okay, so hopefully that makes sense. For now, the 80% rule, just learn about created, mounted, and unmounted, and that'll take you a really long way.

For now, the 80% rule, just learn about created, mounted, and unmounted, and that'll take you a really long way. Okay, so if we want to perform an AJAX request to create all of our assignments, what hook might we use? Well, we could use mounted, but that's after the component has been created and compiled. So it would work, but maybe it would be better to do it one hook before that. So we'll stick with created. Okay, now we can use any kind of JavaScript library you want to perform the AJAX request.

Okay, now we can use any kind of JavaScript library you want to perform the AJAX request. It's very common to use a tool called Axios, but we could also use a native browser tool called Fetch. So let's figure out what the endpoint was. And we'll copy that, paste it in. Now, the Fetch API returns what's known as a promise. And if you're not familiar with promises, here's a really easy way to think of it. When you're working synchronously, you know that you make a request,

here's a really easy way to think of it. When you're working synchronously, you know that you make a request, you instantly receive a response, and then you work with it, right? But that's not true when you're working asynchronously, of course. You will eventually get a response. It's sort of like when somebody owes you money, and they're not giving it to you. And they say, you'll get your money when I have it. But they never actually give it to you right then, that's how I think of it. So a promise is literally a promise to give you a response, but

But they never actually give it to you right then, that's how I think of it. So a promise is literally a promise to give you a response, but it doesn't have anything for you right now, just a promise. That one day or one second, you'll get it. Okay, okay, so the Fetch API returns a promise to give me this data. So why don't we say, all right, well, when you have some data for me, I'll call it response, I actually want the JSON for that response. But then the Fetch API is like, okay, I'll give you that JSON, but not right away, I promise to give it to you though. So that will return another promise.

not right away, I promise to give it to you though. So that will return another promise. So let's do a second then and say, okay, when you have my data, let's console.log it and have a look. Okay, so I visit the browser, I will open up the console and give this a refresh. And if we have a look at the Info tab, sure enough, we have our list of assignments. And just to be crystal clear, those assignments are coming from this database we created. Okay, so the next step is to accept those assignments.

those assignments are coming from this database we created. Okay, so the next step is to accept those assignments. And in fact, we can call it whatever we want. Let's call it assignments. Let's now assign it right here. So I can say, after that AJAX request is complete and we have the assignments, let's save them to that data property. And when we do, we update this. It changes, so view re-renders the DOM. And yeah, you can tweak this as you need to.

It changes, so view re-renders the DOM. And yeah, you can tweak this as you need to. So for example, maybe you'll add another one here. Maybe we have an assignment for finish lyric cast video. And we're about to be done, so we'll set it to true. And that will have a tag of programming. Okay, now keep in mind, if I update this and I give it a refresh, it's not reflected here. Whenever you make a change to your database, make sure you Ctrl C out of your server and boot it up again.

Whenever you make a change to your database, make sure you Ctrl C out of your server and boot it up again. Okay, now if we try it again, it should be reflected. And because we marked that assignment as complete, when we load the page, it automatically renders that second assignment list. So I hope you're excited. This is all such cool stuff. Trust me, when I got started learning, none of these things existed. It was all very difficult. So you are very fortunate, and I hope you're excited for the next lesson.

You can also view the transcript in segments here: 0:00-8:15

If you want me to extract or explain any part of this episode or provide code examples from it, just ask!

## Translation

Aqui está a transcrição completa do Episódio 13: "Lifecycle Hooks, Fake APIs e AJAX" da série "Learn Vue 3: Step by Step" no Laracasts:

Muito bem, bem-vindo de volta. Vamos passar para outra coisa. Até agora, estivemos codificando as tarefas diretamente dentro do nosso componente. Mas claro, isso não é muito realista. Na vida real, esses dados vêm de um banco de dados ou de alguma API. Então, por que não testamos isso usando uma API falsa? Eu vou te mostrar como fazer isso. Vou abrir meu editor. E sim, claro, neste momento, não temos um backend. Só temos um monte de arquivos JavaScript.

Sim, neste momento, não temos um backend. Só temos um monte de arquivos JavaScript. Então, claro, eu poderia usar o Laravel para fornecer nossa API. Mas também estou ciente de que muitas pessoas que assistem isso provavelmente não usam PHP ou Laravel. Então, mesmo que possamos usá-lo no futuro, agora nesta série, quero que os exemplos sejam o mais acessíveis possível. Com isso em mente, vou configurar uma API falsa e te mostrar uma maneira legal de fazer isso. Vou usar o NPM para instalar uma ferramenta chamada JSON Server e salvá-la na minha lista de dependências de desenvolvimento. Agora, se você rodar npm e não funcionar, visite nodejs.org, instale, e então tente novamente. Certo, agora se eu tentar rodar isso, e posso fazer isso usando `npx json-server`, ele exibe a ajuda, mas também vemos um pequeno aviso: "Estamos sem o argumento de origem". Então precisamos criar um banco de dados para ele usar. Vamos fazer isso agora.

Precisamos criar um banco de dados para ele usar. Vamos fazer isso agora. Lembre-se, não estamos criando um banco de dados de verdade. Esta é apenas uma API falsa para testes, e é perfeita para exemplos. Vou chamá-lo de `db.json`. E veja só que legal: se eu quiser um endpoint para buscar tarefas, posso chamá-lo de assignments, e ele deve retornar um array de tarefas. Então, se mudarmos de aba, aqui está o que tínhamos antes. Que tal copiarmos uma daquelas tarefas, colarmos no nosso banco de dados e colarmos ali?

Se mudarmos de aba, aqui está o que tínhamos antes. Que tal copiarmos uma daquelas tarefas, colarmos no nosso banco de dados e colarmos ali? Mas claro, agora isso vai falhar porque não está formatado corretamente. Então vamos garantir que tudo esteja envolto em aspas duplas, assim. E então eu vou reformatar. Pronto, essa é a estrutura básica. Se eu quiser adicionar mais, posso duplicar quantas vezes quiser. Agora, quando eu fizer uma requisição para o endpoint assignments, ele vai me retornar todos esses objetos. Muito legal.

Para economizar tempo, não vou fazer você assistir tudo isso. Vou colar aqui um que escrevi antes. E repare que os nomes correspondem exatamente aos que havíamos codificado no assignments.js. Então, idealmente, eu posso remover todos esses, e em vez disso buscá-los da nossa nova API falsa. Certo, vamos rodar de novo: `npx json-server` com o nome do arquivo `db.json`. Muito bom.

npx json-server com o nome do arquivo db.json. Muito bom. Tenho um recurso chamado assignments pronto para uso. Mas há um pequeno problema. Note que ele está tentando rodar na porta 3000, mas nosso servidor principal também está na porta 3000. Que tal sairmos, rodarmos de novo, e desta vez definirmos a porta como 3001? Assim, eles não vão conflitar. Veja só. Se eu abrir isso no navegador, nosso servidor está rodando, e aqui está nosso endpoint assignments que retorna esses dados.

Se eu abrir isso no navegador, nosso servidor está rodando, e aqui está nosso endpoint assignments que retorna esses dados. Que legal, não é? É perfeito. Exatamente o que precisamos para fins de teste. Agora vamos fazer uma requisição para esse endpoint. E eu vou te mostrar como fazer isso. Se visitarmos assignments.js, qual seria um bom lugar para fazer uma requisição AJAX? Aqui entram os lifecycle hooks.

Aqui entram os lifecycle hooks. Então, vamos dar uma olhada nesse diagrama que o Vue.js fornece.

Aqui está. Este é o ciclo de vida de um componente. E sim, parece um pouco confuso. Ninguém espera que você memorize cada pedaço desse fluxo. Apenas entenda a ideia básica: à medida que um componente é renderizado, montado e depois desmontado, ele passa por uma série de ganchos do ciclo de vida. E aqui estão alguns dos mais comuns:

Antes de criar, criado, montado, desmontado. Por exemplo, se quisermos executar um trecho de código assim que o componente for criado, mas antes de ser compilado, então o hook `created` é o que queremos. E acontece que os nomes desses hooks também são os nomes dos métodos que usamos. Por exemplo, 
```js
created() { alert('created') }
```
, e vamos testar isso. Recarregue a página, e funciona. Os mais comuns que você usará são `created`, `mounted`, que significa que o componente foi criado, compilado e renderizado no DOM.

Então esse é bem comum. Outro comum é quando o componente foi desmontado da página. Você vai usar bastante o `unmounted` ao construir aplicações de página única (SPA), onde talvez precise remover event listeners para liberar memória. Espero que isso faça sentido. Por agora, siga a regra do 80%: aprenda sobre `created`, `mounted` e `unmounted`, e isso já vai te ajudar bastante.

Então, se quisermos fazer uma requisição AJAX para buscar todas as tarefas, qual hook usar? Podemos usar `mounted`, mas isso acontece depois que o componente foi criado e compilado. Vai funcionar, mas talvez seja melhor usar um hook anterior. Então vamos usar `created`. Agora, podemos usar qualquer biblioteca JavaScript para fazer a requisição AJAX.

É muito comum usar uma ferramenta chamada Axios, mas também podemos usar a API nativa do navegador chamada Fetch. Vamos descobrir qual é o endpoint. Copiamos e colamos. A Fetch API retorna o que é chamado de promise. __Se você não estiver familiarizado com promises, aqui vai uma forma fácil de pensar nisso: quando você trabalha de forma síncrona, você faz uma requisição, recebe uma resposta instantaneamente e trabalha com ela, certo?__

__Mas isso não acontece de forma assíncrona. Você eventualmente vai receber uma resposta. É como quando alguém te deve dinheiro e diz "te pago quando eu tiver", mas nunca te dá na hora — é assim que penso nisso. Uma promise é literalmente uma promessa de te dar uma resposta, mas não agora — talvez em um segundo.__ Ok. Então a Fetch API retorna uma promessa de me dar os dados. Podemos dizer: "Ok, quando você tiver os dados para mim, eu os chamo de response", e quero os dados em JSON dessa resposta.

__Mas a Fetch API diz: "Ok, eu te dou esse JSON, mas não agora — eu prometo que vou te dar"__. Então isso retorna outra promise. Vamos fazer um segundo .then() e dizer: "Quando você tiver meus dados, vamos fazer console.log() e ver o que vem". Abro o navegador, console aberto, atualizo, e no painel Info, lá estão nossas tarefas. E só para deixar claro: essas tarefas estão vindo do banco de dados que criamos.

Próximo passo é aceitar essas tarefas. Podemos chamá-las do que quisermos — vamos chamar de assignments. Agora vamos atribuí-las aqui. Podemos dizer que, depois da requisição AJAX ser concluída e tivermos as tarefas, vamos salvá-las na propriedade data. E quando fazemos isso, atualizamos a visualização, o DOM é re-renderizado. E sim, você pode ajustar conforme precisar.

Por exemplo, talvez você adicione mais uma tarefa aqui. Digamos que temos uma tarefa chamada “finalizar vídeo do Laracasts”, e estamos quase terminando, então vamos marcá-la como concluída. E ela terá a tag programming. Lembre-se: se você atualizar isso e recarregar a página, não será refletido aqui. Sempre que fizer uma alteração no seu banco de dados, use Ctrl + C para parar o servidor e inicie-o novamente.

Agora, se testarmos novamente, a mudança será refletida. E como marcamos aquela tarefa como concluída, quando carregamos a página, ela aparece automaticamente na lista de tarefas concluídas. __Espero que você esteja empolgado. Isso tudo é muito legal. Acredite, quando comecei a aprender, nada disso existia. Era tudo muito difícil. Você é muito sortudo, e espero que esteja animado para a próxima lição.__