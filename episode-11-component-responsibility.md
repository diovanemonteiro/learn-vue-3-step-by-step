# Component Responsibility
### In this episode, we'll discuss component responsibility as we refactor to an AssignmentsTags  component. I think of component responsibility in the same way that I think of server-side class responsibility. "Does this bit of logic belong here?"

Here is the full transcript for Episode 11, "Component Responsibility," from the series "Learn Vue 3: Step by Step":

All right, welcome back. So in this episode, we're going to focus on refactoring, but also, more broadly, I'd like to talk about responsibility. And by that I mean, when you're reviewing these components, you should always be thinking, should this component be responsible for that? And it's kind of a tough decision. It's something you will figure out over time. So here's what I mean. If we take a look at the AssignmentList component, this component is responsible for displaying a list of assignments.

If we take a look at the AssignmentList component, this component is responsible for displaying a list of assignments. But now as part of that, we've introduced all of this terminology related to tags. So I have this block here for displaying my tags. If we scroll down, we have this section here for tracking the current tag. And then down here, we have a computed property for gathering and displaying all the tags. And you can just as easily imagine us adding a little button here to add a new tag. And if we took that approach, we would have to introduce another data property, another method that would append this new tag. We would need some kind of logic to maybe save it to the database, or at least store

method that would append this new tag. We would need some kind of logic to maybe save it to the database, or at least store it in local storage. So very quickly, this component that is really just responsible for displaying a list of assignments becomes aware of so many things related to tagging. Okay, so with that in mind, why don't we refactor this? And often what I like to do is start with the template. So this is the section that we will extract. And why don't we call the component, how about AssignmentTags. Now on this node, you may have noticed, let me create this, that all of our components

And why don't we call the component, how about AssignmentTags. Now on this node, you may have noticed, let me create this, that all of our components related to assignments begin with the word assignment. This is actually a pretty common practice in the Vue world. If nothing else, it's a nice way to group everything like so. Imagine if this component was instead named CreateAssignment.js. Well, in a real project where we have dozens and dozens of files, Create.js would be way down here, separate from all of the other assignment-related components. So it's just a common practice that you can adopt if you wish. Okay, so let's export.

So it's just a common practice that you can adopt if you wish. Okay, so let's export. We'll set up our templates. And we'll paste that HTML block. All right, next we need to start a list of tags that we can loop over. Hmm, how should we do this? Well, right now, our tags are being created here. But maybe I could extract this, bring it over to our computed property, and I'll paste that in like so. But now, yeah, we're in that situation again where in order for this to work, our tags

in like so. But now, yeah, we're in that situation again where in order for this to work, our tags component now needs access to all assignments. And I don't love that. So again, an option might be, let's clean this up, to begin by passing our tags here. And maybe I could just do this inline, .map, and all I care about is the tag name. So this would be a way to pass the initial tags. So now, you'll see that we run into another issue. I want to accept an array of tags. But now we end up in a situation where our prop is named tags, but we also have a computed

I want to accept an array of tags. But now we end up in a situation where our prop is named tags, but we also have a computed property named tags, which we don't want and we can't do. So to skirt around this, you have a couple choices. One option would be simply change the computed name, like all tags. And that might be good because we are taking the initial set of tags and we are extending it to also include this all tag name as well. So that might be fine. Another common approach is to do something like this, where you name the prop either data tags or even something like initial tags.

Another common approach is to do something like this, where you name the prop either data tags or even something like initial tags. That would then be your prop name, which would allow you to do this initial tags. And then your computed property could go back to being tags that delegates or defers like so. Yeah, both of these are very common in the Vue world. Okay, next we need the current tag. So here's what I'm going to do. For now, I'm going to add it here, but I think we're going to remove this. But yeah, this would migrate everything over.

For now, I'm going to add it here, but I think we're going to remove this. But yeah, this would migrate everything over. Okay, so now let's switch back. We will import it, import assignment tags. We will register it as a component, and then we use it in a template. Okay, let's have a look in the browser. We give it a refresh and I still see my tags. Let's open up Vue DevTools. All right, here's our assignment list. And now I can see it does consist of a assignment tags component.

All right, here's our assignment list. And now I can see it does consist of a assignment tags component. But now our problem is if I click on one of these, we're not re-rendering the assignment list. So let's figure out why. Well, I go in here, we click on it, we update the current tag, but there's no communication, is there? At no point do we communicate back to assignment list that it needs to then re-render the assignments here. And further, we now have this issue where we're tracking the current tag here, but we

here. And further, we now have this issue where we're tracking the current tag here, but we also are tracking the current tag here. Okay, so your first thought might be, well, we've already learned about events. Maybe this is another situation where we emit an event. All right, let's see what that might look like. When you click on the button, instead of storing the current tag, I could get rid of that, we instead emit an event. Emit, and why don't we call this change, and we'll pass through the tag that was clicked. All right, now if I switch back, if we come up here, we pass through the initial tags,

Emit, and why don't we call this change, and we'll pass through the tag that was clicked. All right, now if I switch back, if we come up here, we pass through the initial tags, and then we listen for when it changes, and what we want to do is update the current tag. So I could say change current tag, we're going to do this inline, equals the tag that was passed through. And when we are responding inline, like we're doing here, remember, we could just as easily call a method, update current tag, right? But when we do it inline, we can access the parameter by using this magic event variable. Okay, so that would work if you think about it. When I click on a specific tag, we emit a change event, and we pass through the tag.

Okay, so that would work if you think about it. When I click on a specific tag, we emit a change event, and we pass through the tag. We then listen for that change event, where we then update the current tag on this component, and make it equal to the tag that was clicked. Okay, so now let's see what that might look like. I will click on math, and it seems to be working, but now we have another issue. We are no longer highlighting the tag that was clicked. And that actually makes sense, if you think about it. If we go back to our tags, you'll remember that we only activate it if the current tag equals the one in the loop.

If we go back to our tags, you'll remember that we only activate it if the current tag equals the one in the loop. But we don't have a current tag here, so maybe that should be passed through as a prop. All right, let's come back. We come over here, we have our initial tags, we have the current tag, and then we listen for an event. When this component announces that we've changed tags, we will update our state as well. All right, we check this out, and yeah, everything's working like it did before. Very cool. And also notice that because each of these assignment lists are their own instances,

Very cool. And also notice that because each of these assignment lists are their own instances, the tags will function independently. So notice here, we have only the tags that are available to this list, whereas this one also includes a science tag as well. But if we complete that, well now there's no more science tags available in progress. It is moved over to completed. And this is, at least for our example, this is what we want. Okay, so I'm happy with this. But in the next episode, I want to see, is there a way that we can use vModel on things

Okay, so I'm happy with this. But in the next episode, I want to see, is there a way that we can use vModel on things other than basic form inputs? And spoiler alert, you can't.

You can also watch or review the transcript starting at 0:00-8:05 for the full context.

## Translation

Aqui está a transcrição completa do Episódio 11, "Responsabilidade do Componente", da série "Aprenda Vue 3: Passo a Passo":

Muito bem, bem-vindo de volta. Neste episódio, vamos focar em refatoração, mas também, de forma mais ampla, gostaria de falar sobre responsabilidade. E com isso quero dizer que, ao revisar esses componentes, você deve sempre pensar: este componente deveria ser responsável por isso? E essa é uma decisão difícil. É algo que você vai entender com o tempo. Então, aqui está o que quero dizer. Se olharmos para o componente AssignmentList, este componente é responsável por exibir uma lista de tarefas.

Mas agora, como parte disso, introduzimos toda essa terminologia relacionada a tags. Então eu tenho esse bloco aqui para exibir minhas tags. Se rolarmos para baixo, temos esta seção aqui para acompanhar a tag atual. E, mais abaixo, temos uma computed property para coletar e exibir todas as tags. E você pode imaginar facilmente que adicionaríamos um botão aqui para adicionar uma nova tag. E se seguíssemos essa abordagem, teríamos que introduzir outra propriedade de dados, outro método que adicionaria essa nova tag. Precisaríamos de algum tipo de lógica para talvez salvar isso no banco de dados ou, pelo menos, armazená-la no local storage.

Então, rapidamente, esse componente que é basicamente responsável por exibir uma lista de tarefas passa a lidar com muitas coisas relacionadas às tags. Ok, com isso em mente, por que não refatoramos isso? Muitas vezes, eu gosto de começar pelo template. Então esta é a seção que vamos extrair. E por que não chamamos o componente de AssignmentTags?

Agora, talvez você tenha notado — deixa eu criar isso — que todos os nossos componentes relacionados a tarefas começam com a palavra "assignment". Isso é uma prática bastante comum no mundo Vue. Se nada mais, é uma maneira conveniente de agrupar tudo assim. Imagine se este componente se chamasse CreateAssignment.js. Bem, em um projeto real com dezenas e dezenas de arquivos, Create.js estaria bem lá embaixo, separado de todos os outros componentes relacionados a tarefas. Então, é apenas uma prática comum que você pode adotar, se quiser. Certo, então vamos exportar.

Vamos configurar nossos templates e colar aquele bloco de HTML. Agora, precisamos começar com uma lista de tags que possamos percorrer com um v-for. Hmm, como devemos fazer isso? Bem, no momento, nossas tags estão sendo criadas aqui. Mas talvez eu possa extrair isso, trazer para nossa computed property, e colar ali. Mas agora, sim, estamos naquela situação de novo onde, para isso funcionar, nosso componente de tags precisa ter acesso a todas as tarefas. E eu não gosto disso.

Então, uma opção poderia ser — vamos limpar isso — começar passando nossas tags diretamente aqui. E talvez eu possa fazer isso em linha, com .map, e tudo que me importa é o nome da tag. Então, isso seria uma forma de passar as tags iniciais. Agora, você verá que enfrentamos outro problema. Quero aceitar um array de tags. Mas acabamos em uma situação onde nossa prop se chama tags, mas também temos uma computed property chamada tags, o que não queremos e nem podemos fazer.

Para contornar isso, você tem algumas opções. Uma delas seria simplesmente mudar o nome da computed property, para algo como allTags. E isso pode ser bom, pois estamos pegando o conjunto inicial de tags e o estendendo para também incluir essa tag "all". Outra abordagem comum é algo assim: você nomeia a prop como dataTags, ou até algo como initialTags.

Esse então seria o nome da sua prop, permitindo que você use initialTags, e então sua computed property poderia voltar a se chamar tags, delegando ou redirecionando o valor. Sim, ambas são abordagens bem comuns no mundo Vue. Ok, agora precisamos da tag atual. Aqui está o que vou fazer: por enquanto, vou adicioná-la aqui, mas acho que vamos removê-la depois. Mas sim, isso migraria tudo para o novo componente.

Agora vamos voltar. Vamos importá-lo, importar o AssignmentTags, registrá-lo como um componente, e usá-lo no template. Vamos dar uma olhada no navegador. Damos um refresh e ainda vejo minhas tags. Vamos abrir o Vue DevTools. Aqui está o nosso AssignmentList, e agora posso ver que ele consiste em um componente AssignmentTags.

Mas agora nosso problema é: se eu clico em uma das tags, a lista de tarefas não está sendo renderizada novamente. Vamos entender por quê. Eu clico aqui, atualizamos a tag atual, mas não há comunicação, certo? Em nenhum momento comunicamos de volta para AssignmentList que ele precisa renderizar novamente as tarefas. E mais: agora temos esse problema onde estamos acompanhando a tag atual aqui, mas também aqui.

Sua primeira ideia pode ser: já aprendemos sobre eventos. Talvez essa seja outra situação onde emitimos um evento. Vamos ver como isso seria. Quando você clica no botão, em vez de armazenar a tag atual, podemos remover isso e, em vez disso, emitir um evento. Emitimos um evento chamado change, e passamos a tag que foi clicada. Agora, se voltarmos aqui, passamos as initialTags e escutamos quando há uma mudança. E o que queremos fazer é atualizar a tag atual.

Podemos fazer isso em linha: @change="currentTag = $event". E, claro, poderíamos chamar um método, tipo updateCurrentTag(). Mas, respondendo em linha, conseguimos acessar o parâmetro usando a variável mágica $event. Isso funcionaria, se você pensar bem. Quando clicamos em uma tag, emitimos um evento change com a tag. Escutamos esse evento e atualizamos a tag atual neste componente com o valor clicado.

Vamos ver como isso fica. Vou clicar em "math", e parece estar funcionando, mas agora temos outro problema: não estamos mais destacando a tag clicada. E isso faz sentido. Se voltarmos para nosso componente de tags, você lembra que só ativamos o estilo se a tag atual for igual à da iteração do loop.

Mas aqui não temos uma tag atual. Talvez ela deva ser passada como uma prop. Vamos voltar. Aqui, temos as initialTags, passamos a currentTag, e escutamos um evento. Quando este componente anuncia que a tag mudou, atualizamos o estado também. Conferimos, e sim, tudo está funcionando como antes. Muito bom.

E também observe que, como cada uma dessas listas de tarefas são instâncias próprias, as tags funcionam de forma independente. Veja aqui: temos apenas as tags disponíveis para esta lista, enquanto a outra inclui uma tag de ciência. Mas se concluirmos aquela tarefa, então não há mais tags de ciência disponíveis em "em andamento". Ela foi movida para "concluídas". E isso, pelo menos no nosso exemplo, é o que queremos.

Certo, estou satisfeito com isso. Mas, no próximo episódio, quero ver se existe uma forma de usar v-model em coisas além de inputs básicos de formulários. E um spoiler: você pode sim.

Você também pode assistir ou revisar a transcrição começando de 0:00 a 8:05 para o contexto completo.